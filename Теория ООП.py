"""
ООП - объектно-ориентированное программирование

Объектно-ориентированное программирование (ООП) — это парадигма программирования, основанная на концепции "объектов",
которые могут содержать данные и код: данные в виде полей (атрибутов), и код в виде процедур (методов). ООП позволяет
организовывать код более структурированно и удобно для повторного использования.

ООП - это методология программирования, основанная на представлении программы в виде совокупности объектов, каждый
из которых является экземпляром определенного класса, а классы образуют иерархию наследования.

Класс - это как чертеж для объекта. Или класс - это инструкция по созданию объекта
Класс можно рассматривать как карту дома. Класс и объект - это как машина (что-то абстрактное / концепция) и Toyota
(уже конкретная марка, конкретная машина)

Класс — это шаблон для создания объектов, который определяет набор атрибутов и методов, которые будут у этих объектов.
Классы являются основным строительным блоком объектно-ориентированного программирования (ООП) в Python и позволяют
организовывать код более структурированно.

Класс определяется с помощью ключевого слова class, за которым следует имя класса и двоеточие. Внутри класса можно
определить методы и атрибуты.

В классе лежат методы.
Метод - это функия нашего класса

"""

class Alphabet:
    """Класс по созданию и работе с алфавитом"""
    def __init__(self, title, abbreviation, list_letters):
        """Аргументы класса"""
        self.title = title                  # Атрибут класса
        self.abbreviation = abbreviation    # Атрибут класса
        self.list_letters = list_letters    # Атрибут класса
        print("Новый алфавит создан")

russian = Alphabet("Русский", "RU", "абвгдеёжзийклмнопрстуфхцчшщъыьэюя")

"""

Наш класс включает в себя метод __init__ c перечислением всех обязательных аргументов данного класса
Метод — это функция, которая связана с объектом и определена внутри класса. Методы позволяют выполнять операции 
с данными, которые хранятся в экземплярах классов, и обеспечивают возможность взаимодействия с объектами. 
Проще говоря, метод - это функция, которая принадлежит классу.


В Python метод __init__ является специальным методом, который используется для инициализации объектов класса. 
Он автоматически вызывается при создании нового экземпляра класса. Атрибуты могут быть заданы при создании объекта.

Без __init__:

python
class Pizza:
    pass

my_pizza = Pizza()
my_pizza.size = "большая"    # Приходится вручную
my_pizza.toppings = "пепперони"  # устанавливать
my_pizza.price = 500         # каждый атрибут

С __init__:

python
class Pizza:
    def __init__(self, size, toppings, price):
        self.size = size      # ВСЁ устанавливается
        self.toppings = toppings  # автоматически
        self.price = price    # при создании

my_pizza = Pizza("большая", "пепперони", 500)  # Всё готово!


self — это специальный параметр, который используется в методах классов для ссылки на текущий экземпляр объекта. 
Он позволяет методам класса получать доступ к атрибутам и другим методам этого экземпляра.  
Он говорит что данный атрибут относится к этому классу и позволяет с ним взаимодействовать.


Наш метод __init__, так же можно встретить название конструктор, включает в себя перечень обязательных атрибутов 
данного класса - характеристики алфавита.


Краткое резюме:
__init__ - создает атрибуты у нового объекта
self - дает доступ к этим атрибутам из методов
Без self объект не знал бы, с какими именно данными работать!


title - название (название алфавита)
abbreviation - аббревиатура
list_letters - список букв

У каждого алфавита есть название, аббревиатура и список букв. Так же при создании экземпляра класса, 
Мы будем получать сообщение print("Новый алфавит создан").


Экземпляр класса — это конкретный объект, созданный на основе определения класса. Класс можно рассматривать как шаблон 
или чертеж, а экземпляр класса — как конкретное применение этого шаблона. Каждый экземпляр класса может иметь свои 
собственные атрибуты и методы, определенные в классе.

russian = Alphabet("Русский", "RU", "абвгдеёжзийклмнопрстуфхцчшщъыьэюя")


russian - имя экземпляра класса

Alphabet - имя класса

"Русский", "RU", "абвгдеёжзийклмнопрстуфхцчшщъыьэюя" - перечисление значений для экземпляра класса

Мы можем обратиться к нашему экземпляру класса и получить значение одного из его атрибутов.

Например, если Мы хотим получить название нового алфавита, нам необходимо прописать:

print(russian.title)
Результат: Русский


    Для удобства. На примере единственного человека это не очень заметно, но представьте, что вам нужно смоделировать группу
студентов. Можно создать класс "студент" с атрибутами и методами. Далее набор экземпляров класса, в которых определяются 
атрибуты. И после все эти экземпляры засунуть в список, к примеру. 
    А теперь представьте насколько удобно это будет сделать без ооп (можно засунуть все атрибуты в список или словарь,
а функции определить отдельно, но в дальнейшем оперировать подобным нагромождением будет не очень удобно)

 
 Что такое ООП? (Deepseek)
ООП (Объектно-Ориентированное Программирование) - это способ писать программы, где всё представлено как "объекты" из реального мира.

Представь, что у тебя есть:
Класс = чертеж машины
Объект = конкретная машина, сделанная по этому чертежу
Атрибуты = цвет, марка, скорость машины
Методы = завестись, ехать, остановиться


Без ООП:

# Куча переменных!
tiger_name = "Тигр"
tiger_weight = 200
tiger_country = "Россия"

elephant_name = "Слон" 
elephant_wei7ht = 5000
elephant_country = "Индия"


С ООП:

# Всё организовано!
tiger = Animal("Тигр", 200, "Россия")
elephant = Animal("Слон", 5000, "Индия")
 
Главные принципы ООП:

Инкапсуляция - объединяем данные и методы в одном объекте
Наследование - можно создавать новые классы на основе существующих
Полиморфизм - разные объекты могут иметь одинаковые методы
ООП помогает писать более понятный и организованный код!
"""

# ИНКАПСУЛЯЦИЯ
class BankAccount:
    """банковский счет - пример инкапсуляции (объединение данных /атрибутов/ и действия /методы/ внутри одного объекта)"""


    def __init__(self, owner, balance=0):
        # Данные (атрибуты)
        self.owner = owner
        self.__balance = balance  # скрытый атрибут __balance: т.е. нельзя трогать напрямую

        # Действия (методы)
    def deposit(self, amount):
        """Положить деньги на счет"""
        self.__balance += amount  # увеличиваем баланс
        print(f"Пополнение: +{amount}. Баланс: {self.__balance}")

    def withdraw(self, amount):
        """Снять деньги со счета"""
        if amount <= self.__balance:  # проверка баланса
            self.__balance -= amount  # уменьшаем баланс
            print(f"Снятие: -{amount}. Баланс: {self.__balance}")
        else:
            print("Недостаточно средств")

    def get_balance(self):
        """Узнать баланс"""
        return self.__balance

# Создаем объект
my_account = BankAccount("Андрей", 100500)


# Используем методы
my_account.deposit(2500)  # Пополнение: +2500. Баланс: 103000
my_account.withdraw(100000)  # Снятие: -100000. Баланс: 3000
print(my_account.get_balance())  # 3000

# ЧТО НЕЛЬЗЯ ДЕЛАТЬ (скрытые атрибуты):
# print(account.__balance)    # ОШИБКА! Не видно снаружи
# account.__balance = 1000000 # Не меняет настоящий баланс!

'''
__balance - скрытый атрибут (двойное подчеркивание)
Методы deposit, withdraw, get_balance - контролируют доступ к балансу
Польза: Защищаем данные от неправильного использования
'''

# НАСЛЕДОВАНИЕ
class Animal:
    """Класс животного - родительский класс (новый класс на основе существующего, перенимая все его свойства"""

    def __init__(self, name, age):
        self.name = name  # имя животного
        self.age = age  # возраст животного

    def eat(self):
        """Метод 'есть' - общий для всех животных"""
        print(f"{self.name} кушает")

    def sleep(self):
        """Метоод 'спать' - общий для всех животных"""
        print(f"{self.name} спит")

# Дочерние классы (наследники):
class Dog(Animal):  # Dog наследуется от Animal
    """Класс собаки - дочерний класс"""

    def bark(self):
        """Метод 'лаять' - только у собак"""
        print(f"{self.name} гавкает: Гав-гав!")

    # ПЕРЕОПРЕДЕЛЕНИЕ метода (полиморфизм):
    def eat(self):
        print(f"{self.name} быстро хватает еду и виляет хвостом!")

class Cat(Animal):  # Cat наследуется от Animal
    """Класс кошки - дочерний класс"""

    def meow(self):
        """Метод 'мяукать' - только у кошек"""
        print(f"{self.name} мяукает: Мяу-мяу!")

    def eat(self):
        print(f"{self.name} аккуратно ест и умывается")

# СОЗДАЕМ ОБЪЕКТЫ
dog = Dog("Бобик", 3)
cat = Cat("Мурка", 1)

# ИСПОЛЬЗУЕМ УНАСЛЕДОВАННЫЕ методы:
dog.eat()  # Бобик быстро хватает еду и виляет хвостом!
dog.sleep()  # Бобик спит
dog.bark()  # Бобик гавкает: Гав-гав!

cat.eat()  # Мурка аккуратно ест и умывается
cat.meow()  # Мурка мяукает: Мяу-мяу!
cat.sleep()  # Мурка спит

'''
Dog и Cat получают все методы и атрибуты от Animal
Каждый дочерний класс может добавлять свои уникальные методы
Можно переопределять родительские методы
'''

# ПОЛИМОРФИЗМ
# (Одно действие - разные реализации)

class Shape:
    """Класс фигуры"""

    def area(self):
        """Площадь фигуры - будет переопределен в дочерних классах"""
        pass

    def describe(self):
        """Описание фигуры"""
        print("Это геометрическая фигура")

# ДОЧЕРНИЕ КЛАССЫ с РАЗНЫМИ реализациями:
class Circle(Shape):
    """Класс круга"""

    def __init__(self, radius):
        self.radius = radius  # радиус круга

    # ПОЛИМОРФИЗМ: тот же метод area, но другая реализация
    def area(self):
        """Площадь круга = pi * r**2"""
        return 3.14 * self.radius ** 2

    def describe(self):
        print(f"Это круг с радиусом {self.radius}")

class Rectangle(Shape):
    """Класс прямоугольника"""

    def __init__(self, width, heigh):
        self.width = width  # ширина прямоугольника
        self.heigh = heigh  # высота прямоугольника

    # ПОЛИМОРФИЗМ: тот же метод area, но другая реализация
    def area(self):
        """Площадь прямоугольника = ширина * высота"""
        return self.width * self.heigh

    def describe(self):
        print(f"Это прямоугольник {self.width}*{self.heigh}")

class Triangle(Shape):
    """Класс треугольника"""

    def __init__(self, base, height):
        self.base = base  # основание треугольника
        self.height = height  # высота треугольника

    # ПОЛИМОРФИЗМ: тот же метод, но другая реализация

    def area(self):
        """Площадь треугольника = (основание * высота) / 2"""
        return (self.base * self.height) / 2

    def describe(self):
        print(f"Это треугольник с основанием {self.base} и высотой {self.height}")

# ДЕМОНСТРАЦИЯ ПОЛИМОРФФИЗМА:
shapes = [
    Circle(5),
    Rectangle(4,6),
    Triangle(3,4)
]

# ОДИНАКОВЫЙ код для РАЗНЫХ объектов:
for shape in shapes:
    shape.describe()                   # вызываем describe для каждой фигуры
    print(f"Площадь: {shape.area()}")  # вызываем area для каждой фигуры

# Это круг с радиусом 5
# Площадь: 78.5
# Это прямоугольник 4*6
# Площадь: 24
# Это треугольник с основанием 3 и высотой 4
# Площадь: 6.0


"""
У всех фигур есть методы area() и describe()
Но каждый класс реализует их ПО-СВОЕМУ
Мы можем работать с разными фигурами ОДИНАКОВО, не зная их конкретного типа

КРАТКОЕ РЕЗЮМЕ:
ИНКАПСУЛЯЦИЯ = "Упаковка" данных и методов вместе + защита
НАСЛЕДОВАНИЕ = "Родитель-ребенок" - перенимаем свойства
ПОЛИМОРФИЗМ = "Одно название - разное поведение"

Аналогия из жизни:
Инкапсуляция - автомобиль: тебе не нужно знать КАК работает двигатель, ты просто нажимаешь педаль газа
Наследование - транспорт: машина, велосипед, самолет - все они "транспортные средства"
Полиморфизм - кнопка "включить": у телевизора, компьютера, телефона работает по-разному, но называется одинаково
"""


class Car:

    def __init__(self, brand, max_speed):
        self.brand = brand  # публично - марка машины
        self.__speed = 0  # скрыто - текущая скорость
        self.__max_speed = max_speed  # скрыто - максимальная скорость

    def accelerate(self, kmh):
        """Ускориться безопасно"""
        new_speed = self.__speed + kmh
        if new_speed <= self.__max_speed:
            self.__speed = new_speed
            print(f"Скорость: {self.__speed} км/ч")
        else:
            self.__speed = self.__max_speed
            print(f"Достигнута максимальная скорость: {self.__max_speed} км/ч")

    def get_speed(self):
        """Узнать текущую скорость"""
        return self.__speed

car = Car("Toyota", 180)

# МОЖНО:
car.accelerate(50)  # Скорость: 50 км/ч
car.accelerate(100)  # Скорость: 150 км/ч
car.accelerate(50)  # Достигнута максимальная скорость: 180 км/ч
print(car.get_speed())  # 180

# НЕЛЬЗЯ:
car.__speed = 300  # Не изменит настоящиую скорость!
car.__max_speed = 500  # Не сломает ограничитель!


class Temperature:
    def __init__(self, celsius):
        self.__celsius = celsius  # храним только в Цельсиях

    def get_celsius(self):
        return self.__celsius

    def get_fahrenheit(self):
        return (self.__celsius * 9/5) + 32  # всегда актуально

    def set_celsius(self, value):
        if -273.15 <= value <= 1000:  # проверка!
            self.__celsius = value
        else:
            print("Невозможная температура!")

temp = Temperature(25)
print(temp.get_fahrenheit())  # 77.0 - всегда правильное значение


"""
КОГДА ИСПОЛЬЗОВАТЬ СКРЫТЫЕ АТРИБУТЫ:
✅ Данные, которые не должны меняться напрямую (баланс, пароль)
✅ Внутренняя логика работы (соединение с базой, кэш)
✅ Проверка значений перед сохранением (температура, скорость)

❌ Простые данные (имя, цвет, описание)
Золотое правило: "Скрывай всё, что может сломать работу объекта если изменить это неправильно"
"""